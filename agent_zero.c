/*
 * Agent Zero - Master Builder for rsyncd.conf Orchestration
 *
 * Copyright (C) 2025 OpenCog Cognitive Architecture Project
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 */

#include "cogagent.h"
#include "atomspace.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

/* Define strlcpy if not available */
#ifndef HAVE_STRLCPY
static size_t strlcpy(char *dest, const char *src, size_t size)
{
    size_t len = strlen(src);
    if (size > 0) {
        size_t copy_len = (len >= size) ? size - 1 : len;
        memcpy(dest, src, copy_len);
        dest[copy_len] = '\0';
    }
    return len;
}
#endif

/**
 * Agent Zero Configuration Builder Data
 */
struct agent_zero_data {
    char config_path[1024];
    FILE *config_file;
    int daemon_count;
    int module_count;
    struct atom_space *atomspace;
};

/**
 * agent_zero_init - Initialize agent zero
 * @agent: Agent zero instance
 * @atomspace: AtomSpace for topology management
 * @config_path: Path to generate rsyncd.conf
 *
 * Returns: 0 on success, -1 on failure
 */
int agent_zero_init(struct cog_agent *agent, struct atom_space *atomspace,
                   const char *config_path)
{
    struct agent_zero_data *data;
    
    if (!agent || !atomspace || !config_path)
        return -1;
    
    data = malloc(sizeof(struct agent_zero_data));
    if (!data)
        return -1;
    
    memset(data, 0, sizeof(struct agent_zero_data));
    
    strlcpy(data->config_path, config_path, sizeof(data->config_path));
    data->atomspace = atomspace;
    
    agent->agent_data = data;
    agent->atomspace = atomspace;
    
    return 0;
}

/**
 * agent_zero_write_global_section - Write global rsyncd.conf parameters
 * @data: Agent zero data
 *
 * Returns: 0 on success, -1 on failure
 */
static int agent_zero_write_global_section(struct agent_zero_data *data)
{
    if (!data || !data->config_file)
        return -1;
    
    fprintf(data->config_file,
        "# rsyncd.conf - Generated by Agent Zero (OpenCog Orchestration)\n"
        "# Autonomous multi-agent rsync daemon configuration\n"
        "# AtomSpace-backed distributed cognitive architecture\n\n");
    
    fprintf(data->config_file,
        "# Global Parameters\n"
        "motd file = /etc/rsync/motd\n"
        "pid file = /var/run/rsyncd.pid\n"
        "port = 873\n"
        "log file = /var/log/rsyncd.log\n"
        "syslog facility = daemon\n"
        "max connections = 100\n\n");
    
    return 0;
}

/**
 * agent_zero_build_daemon_module - Build module configuration from AtomSpace
 * @data: Agent zero data
 * @daemon_atom: Daemon atom from AtomSpace
 * @module_atom: Module atom from AtomSpace
 *
 * Returns: 0 on success, -1 on failure
 */
static int agent_zero_build_daemon_module(struct agent_zero_data *data,
                                          struct atom *daemon_atom,
                                          struct atom *module_atom)
{
    if (!data || !data->config_file || !module_atom)
        return -1;
    
    /* Write module section header */
    fprintf(data->config_file, "[%s]\n", module_atom->name);
    
    /* Write basic module parameters */
    fprintf(data->config_file,
        "    comment = Cognitive module managed by Agent Zero\n"
        "    path = /var/rsync/%s\n"
        "    read only = no\n"
        "    list = yes\n"
        "    uid = nobody\n"
        "    gid = nogroup\n"
        "    auth users = coguser\n"
        "    secrets file = /etc/rsyncd.secrets\n",
        module_atom->name);
    
    /* Add cognitive metadata */
    fprintf(data->config_file,
        "    # AtomSpace Handle: %llu\n"
        "    # Truth Value: strength=%.3f confidence=%.3f\n"
        "    # Attention: STI=%d LTI=%d\n",
        (unsigned long long)module_atom->handle,
        module_atom->tv.strength,
        module_atom->tv.confidence,
        (int)module_atom->av.sti,
        (int)module_atom->av.lti);
    
    fprintf(data->config_file, "\n");
    
    data->module_count++;
    
    return 0;
}

/**
 * agent_zero_build_swarm_modules - Build modules for swarm formation
 * @data: Agent zero data
 * @swarm_atom: Swarm atom from AtomSpace
 *
 * Returns: 0 on success, -1 on failure
 */
static int agent_zero_build_swarm_modules(struct agent_zero_data *data,
                                          struct atom *swarm_atom)
{
    if (!data || !data->config_file || !swarm_atom)
        return -1;
    
    /* Write swarm-specific configuration section */
    fprintf(data->config_file,
        "# HyperGNN Swarm Formation: %s\n"
        "# Swarm Handle: %llu\n\n",
        swarm_atom->name,
        (unsigned long long)swarm_atom->handle);
    
    fprintf(data->config_file,
        "[swarm_%s]\n"
        "    comment = HyperGNN Swarm Formation Module\n"
        "    path = /var/rsync/swarms/%s\n"
        "    read only = no\n"
        "    list = yes\n"
        "    uid = nobody\n"
        "    gid = nogroup\n"
        "    auth users = swarmuser\n"
        "    secrets file = /etc/rsyncd.secrets\n"
        "    # Swarm coordination enabled\n"
        "    # Multi-agent sync formation active\n\n",
        swarm_atom->name,
        swarm_atom->name);
    
    return 0;
}

/**
 * agent_zero_generate_config - Generate rsyncd.conf from AtomSpace topology
 * @agent: Agent zero instance
 *
 * Returns: 0 on success, -1 on failure
 */
int agent_zero_generate_config(struct cog_agent *agent)
{
    struct agent_zero_data *data;
    size_t i;
    struct atom *atom;
    
    if (!agent || !agent->agent_data)
        return -1;
    
    data = (struct agent_zero_data *)agent->agent_data;
    
    /* Open config file for writing */
    data->config_file = fopen(data->config_path, "w");
    if (!data->config_file)
        return -1;
    
    /* Write global section */
    if (agent_zero_write_global_section(data) != 0) {
        fclose(data->config_file);
        return -1;
    }
    
    /* Scan AtomSpace for daemon and module atoms */
    fprintf(data->config_file, "# Cognitive Module Definitions\n\n");
    
    for (i = 0; i < data->atomspace->atom_table_size; i++) {
        for (atom = data->atomspace->atom_table[i]; atom;
             atom = atom->hash_next) {
            
            /* Build modules for rsync daemon nodes */
            if (atom->type == ATOM_MODULE) {
                agent_zero_build_daemon_module(data, NULL, atom);
            }
            
            /* Build swarm formation modules */
            else if (atom->type == ATOM_SWARM) {
                agent_zero_build_swarm_modules(data, atom);
            }
        }
    }
    
    /* Write footer */
    fprintf(data->config_file,
        "# End of Agent Zero generated configuration\n"
        "# Total modules: %d\n"
        "# Generated by OpenCog Autonomous Multi-Agent Orchestration\n",
        data->module_count);
    
    fclose(data->config_file);
    data->config_file = NULL;
    
    return 0;
}

/**
 * agent_zero_add_module - Add module to configuration via AtomSpace
 * @agent: Agent zero instance
 * @module_name: Module name
 * @path: Module path
 * @read_only: Read-only flag
 *
 * Returns: Module atom or NULL on failure
 */
struct atom *agent_zero_add_module(struct cog_agent *agent,
                                  const char *module_name,
                                  const char *path,
                                  int read_only)
{
    struct agent_zero_data *data;
    struct atom *module_atom;
    struct atom *path_atom;
    struct atom *link_atoms[2];
    
    if (!agent || !agent->agent_data || !module_name || !path)
        return NULL;
    
    data = (struct agent_zero_data *)agent->agent_data;
    
    /* Create module atom */
    module_atom = atomspace_add_node(data->atomspace, ATOM_MODULE,
                                    module_name);
    if (!module_atom)
        return NULL;
    
    /* Create path atom */
    path_atom = atomspace_add_node(data->atomspace, ATOM_SYNC_PATH, path);
    if (!path_atom)
        return NULL;
    
    /* Link module to path */
    link_atoms[0] = module_atom;
    link_atoms[1] = path_atom;
    atomspace_add_link(data->atomspace, LINK_DEPENDENCY, link_atoms, 2);
    
    /* Set truth value based on read_only status */
    atom_set_tv(module_atom, read_only ? 0.5 : 1.0, 0.9);
    
    /* Increase attention for new modules */
    atom_set_sti(module_atom, 100);
    
    return module_atom;
}

/**
 * agent_zero_add_swarm - Add swarm formation to configuration
 * @agent: Agent zero instance
 * @swarm_name: Swarm identifier
 * @member_modules: Array of module names in swarm
 * @member_count: Number of members
 *
 * Returns: 0 on success, -1 on failure
 */
int agent_zero_add_swarm(struct cog_agent *agent, const char *swarm_name,
                        const char **member_modules, size_t member_count)
{
    struct agent_zero_data *data;
    struct atom **members;
    size_t i;
    
    if (!agent || !agent->agent_data || !swarm_name ||
        !member_modules || member_count == 0)
        return -1;
    
    data = (struct agent_zero_data *)agent->agent_data;
    
    /* Find member atoms */
    members = malloc(sizeof(struct atom *) * member_count);
    if (!members)
        return -1;
    
    for (i = 0; i < member_count; i++) {
        members[i] = atomspace_find_node(data->atomspace, ATOM_MODULE,
                                        member_modules[i]);
        if (!members[i]) {
            free(members);
            return -1;
        }
    }
    
    /* Create swarm in AtomSpace */
    if (atomspace_create_swarm(data->atomspace, swarm_name, members,
                              member_count) != 0) {
        free(members);
        return -1;
    }
    
    free(members);
    
    return 0;
}

/**
 * agent_zero_task_handler - Handle tasks for agent zero
 * @agent: Agent zero instance
 * @task_data: Task-specific data
 *
 * Returns: 0 on success, -1 on failure
 */
int agent_zero_task_handler(struct cog_agent *agent, void *task_data)
{
    if (!agent)
        return -1;
    
    /* Default task: regenerate configuration */
    return agent_zero_generate_config(agent);
}
